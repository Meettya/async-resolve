// Generated by CoffeeScript 1.10.0

/*
This class implement node.js require.resolve() behavior, with some enhancements:
  - resolve by given 'basedir'
  - do it async (really async, no one sync function used)

Also it support additional extensions (may be set in constructor).

May be used as successor of https://github.com/substack/node-resolve.
Not drop-in, but mostly worked with some changes
 */
var AsyncCache, CoreModulesList, Resolver, filter, find, fs, map, path, reduce, some,
  bind = function(fn, me){ return function(){ return fn.apply(me, arguments); }; },
  slice = [].slice;

fs = require('fs');

path = require('path');

filter = require('lodash.filter');

find = require('lodash.find');

map = require('lodash.map');

reduce = require('lodash.reduce');

some = require('lodash.some');

AsyncCache = require('async-cache');

CoreModulesList = require('./core_list');

module.exports = Resolver = (function() {
  var CORE_MODULES, ERROR, MODULE_FOUND, MODULE_NOT_FOUND;

  CORE_MODULES = reduce(CoreModulesList, (function(memo, val) {
    memo[val] = true;
    return memo;
  }), {});

  ERROR = 'error';

  MODULE_FOUND = 'module.found';

  MODULE_NOT_FOUND = 'module.not_found';


  /*
  May be used with options, default are:
  
  options =
    log : off
    extensions  : ['.js', '.json', '.node']
  
  as base I use settings from https://github.com/substack/node-resolve
   */

  function Resolver(_options_) {
    var ref, ref1;
    this._options_ = _options_ != null ? _options_ : {};
    this._buldResultCallback = bind(this._buldResultCallback, this);
    this._do_logging_ = (this._options_.log != null) && this._options_.log === true && ((typeof console !== "undefined" && console !== null ? console.log : void 0) != null);
    this._node_modules_dirname_ = (ref = this._options_.modules) != null ? ref : 'node_modules';
    this._known_ext_ = (ref1 = this._options_.extensions) != null ? ref1 : ['.js', '.json', '.node'];
    this._dir_load_steps_ = ['package.json'].concat(this._buildDirLoadSteps(this._known_ext_));
    this._fs_ = {
      exists: this._buildCachedFunction('fs.exists'),
      readdir: this._buildCachedFunction('fs.readdir'),
      readFile: this._buildCachedFunction('fs.readFile'),
      stat: this._buildCachedFunction('fs.stat')
    };
  }


  /*
  Alias to resolveAbsolutePath()
   */

  Resolver.prototype.resolve = function() {
    var args;
    args = 1 <= arguments.length ? slice.call(arguments, 0) : [];
    return this.resolveAbsolutePath.apply(this, args);
  };


  /*
  This method create absolute path for file loader
   */

  Resolver.prototype.resolveAbsolutePath = function(path_name, basedir, main_cb) {
    var res_cb;
    res_cb = this._buldResultCallback(path_name, basedir, main_cb);
    switch (path_name.charAt(0)) {
      case '.':
      case path.sep:
        this._debug('This is file or directory', path_name);
        return this._processFileOrDirectory(path_name, basedir, res_cb);
      default:
        this._debug('This is module', path_name);
        return this._processModule(path_name, basedir, res_cb);
    }
  };


  /*
  This method will used to add extensions, keep based untouched
   */

  Resolver.prototype.addExtensions = function() {
    var extensions;
    extensions = 1 <= arguments.length ? slice.call(arguments, 0) : [];
    this._known_ext_ = this._known_ext_.concat(extensions);
    return this._dir_load_steps_ = this._dir_load_steps_.concat(this._buildDirLoadSteps(extensions));
  };


  /*
  This method get internal state, may be used in tests and debug
   */

  Resolver.prototype.getState = function() {
    return {
      dir_load_steps: this._dir_load_steps_,
      extensions: this._known_ext_,
      log: this._do_logging_,
      modules: this._node_modules_dirname_
    };
  };


  /*
  This method chech is filename is core module
   */

  Resolver.prototype.isCoreModule = function(filename) {
    return CORE_MODULES[filename] != null;
  };


  /*
  This internal method create res_cb - result callback
  its wrapper form main_cb with some checker, bulded as event emmiter substitutor
  to fix bug - events are global and shared to all async execution, 
  and, yes, its case some numbers returns
   */

  Resolver.prototype._buldResultCallback = function(path_name, basedir, main_cb) {
    return (function(_this) {
      return function(event_name, in_data) {
        var err;
        switch (event_name) {
          case MODULE_FOUND:
            _this._debug('MODULE_FOUND FROM EVENT');
            return main_cb(null, in_data);
          case MODULE_NOT_FOUND:
            _this._debug('MODULE_NOT_FOUND FROM EVENT');
            err = new Error("Cannot find module |" + path_name + "| at basedir |" + basedir + "|");
            err.code = 'MODULE_NOT_FOUND';
            return main_cb(err);
          case ERROR:
            return main_cb(new Error(in_data));
          default:
            _this._debug("WTF!!?? unknow event " + event_name);
            return main_cb(new Error("can`t do |" + event_name + "|"));
        }
      };
    })(this);
  };


  /*
  This method buld cached function
   */

  Resolver.prototype._buildCachedFunction = function(function_name) {
    var load, max, maxAge;
    max = function_name === 'fs.readFile' ? 100 : 1000;
    maxAge = 1000 * 5;
    load = (function() {
      switch (function_name) {
        case 'fs.exists':
          return function(key, cb) {
            return fs.exists(key, cb);
          };
        case 'fs.readdir':
          return function(key, cb) {
            return fs.readdir(key, cb);
          };
        case 'fs.readFile':
          return function(key, cb) {
            return fs.readFile(key, cb);
          };
        case 'fs.stat':
          return function(key, cb) {
            return fs.stat(key, cb);
          };
        default:
          throw Error("WTF!!?? unknow cached function name " + function_name);
      }
    })();
    return new AsyncCache({
      max: max,
      maxAge: maxAge,
      load: load
    });
  };


  /*
  This internal method create directory resolution patterns in correct steps
   */

  Resolver.prototype._buildDirLoadSteps = function(extensions) {
    return map(extensions, function(val) {
      return "index" + val;
    });
  };


  /*
  Short-cut debugging
   */

  Resolver.prototype._debug = function() {
    var args;
    args = 1 <= arguments.length ? slice.call(arguments, 0) : [];
    if (this._do_logging_) {
      console.log.apply(console, args);
    }
    return null;
  };


  /*
  This method process module
   */

  Resolver.prototype._processModule = function(path_name, basedir, res_cb) {
    var detect_series, detector;
    if (this.isCoreModule(path_name)) {
      return res_cb(MODULE_FOUND, path_name);
    }
    detector = (function(_this) {
      return function(val, cb) {
        var test_path;
        test_path = path.resolve(val, path_name);
        return _this._fs_.exists.get(test_path, function(res) {
          if (res) {
            return cb(true);
          }
          return _this._fs_.exists.get(path.dirname(test_path), function(maybe) {
            return cb(false, maybe);
          });
        });
      };
    })(this);
    detect_series = (function(_this) {
      return function() {
        var int_res_cb, other_paths, try_path;
        int_res_cb = arguments[0], try_path = arguments[1], other_paths = 3 <= arguments.length ? slice.call(arguments, 2) : [];
        if (!try_path) {
          return int_res_cb(MODULE_NOT_FOUND);
        }
        return detector(try_path, function(is_exist, maybe) {
          if (is_exist) {
            return _this._processFileOrDirectory(path_name, try_path, int_res_cb);
          } else if (maybe) {
            return _this._processFileOrDirectory(path_name, try_path, function(event_name, in_data) {
              if (event_name === MODULE_FOUND) {
                return int_res_cb(event_name, in_data);
              } else {
                return detect_series.apply(null, [int_res_cb].concat(slice.call(other_paths)));
              }
            });
          } else {
            return detect_series.apply(null, [int_res_cb].concat(slice.call(other_paths)));
          }
        });
      };
    })(this);
    return detect_series.apply(null, [res_cb].concat(slice.call(this._buildNodeModulesPathes(basedir))));
  };


  /*
  Build all possible node_modules dirs for selected dir
  code was adapted from node\lib\module.js
   */

  Resolver.prototype._buildNodeModulesPathes = function(from) {
    var all_paths, idx, parts, tip;
    parts = from.split(path.sep);
    all_paths = (function() {
      var i, len, results;
      results = [];
      for (idx = i = 0, len = parts.length; i < len; idx = ++i) {
        tip = parts[idx];
        if (tip !== this._node_modules_dirname_) {
          results.push(path.join.apply(path, [path.sep].concat(slice.call(parts.slice(0, idx + 1)), [this._node_modules_dirname_])));
        }
      }
      return results;
    }).call(this);
    return all_paths.reverse();
  };


  /*
  This internal method resolve situation if more than one file was defined in directory
  In this case resolution will be based on extension order
   */

  Resolver.prototype._resolveFileByExtentionOrder = function(files) {
    var ext, i, len, ref, res;
    ref = this._known_ext_;
    for (i = 0, len = ref.length; i < len; i++) {
      ext = ref[i];
      if ((res = find(files, function(val) {
        return ext === path.extname(val);
      }))) {
        return res;
      }
    }
  };


  /*
  This method process file or directory
   */

  Resolver.prototype._processFileOrDirectory = function(path_name, basedir, res_cb) {
    var path_prefix, path_suffix;
    path_name = path.resolve(basedir, path_name);
    path_prefix = path.dirname(path_name);
    path_suffix = path.basename(path_name);
    return this._processPath(path_prefix, path_suffix, res_cb, (function(_this) {
      return function(filtered) {
        var first_filtered;
        _this._debug('_processFileOrDirectory filtered', filtered);
        switch (filtered.length) {
          case 0:
            _this._debug('Not found');
            return res_cb(MODULE_NOT_FOUND);
          case 1:
            _this._debug('find one');
            return _this._processGodsend(path.resolve(path_prefix, filtered[0]), res_cb);
          default:
            _this._debug('find some files, resolve by extension order', filtered);
            first_filtered = _this._resolveFileByExtentionOrder(filtered);
            return _this._processGodsend(path.resolve(path_prefix, first_filtered), res_cb);
        }
      };
    })(this));
  };


  /*
  This method look closer to our godsend and find out what is it really
   */

  Resolver.prototype._processGodsend = function(thing_path, res_cb) {
    return this._fs_.stat.get(thing_path, (function(_this) {
      return function(err, stat_obj) {
        if (err) {
          return res_cb(ERROR, err);
        }
        if (stat_obj.isFile()) {
          _this._debug('WAY!!! its file!!!');
          return res_cb(MODULE_FOUND, thing_path);
        } else if (stat_obj.isDirectory()) {
          _this._debug('HM, big directory, not bad :)');
          return _this._processDirectory(thing_path, res_cb);
        } else {
          _this._debug('WTF?? Cant process it, sorry');
          return res_cb(MODULE_NOT_FOUND);
        }
      };
    })(this));
  };


  /*
  This method process directory as node.js resolve
   */

  Resolver.prototype._processDirectory = function(dir_path, res_cb) {
    return this._fs_.readdir.get(dir_path, (function(_this) {
      return function(err, dir) {
        var file_name, filtered;
        if (err) {
          return res_cb(ERROR, err);
        }
        filtered = _this._multiGrep(_this._dir_load_steps_, dir);
        _this._debug('_processDirectory filtered', filtered);
        switch (file_name = filtered[0]) {
          case void 0:
            _this._debug('Nothing finded, not a module');
            return res_cb(MODULE_NOT_FOUND);
          case 'package.json':
            _this._debug('this is |package.json|');
            return _this._tryProcessJSON(dir_path, file_name, filtered.slice(1), res_cb);
          default:
            _this._debug('just return file', path.resolve(dir_path, file_name));
            return res_cb(MODULE_FOUND, path.resolve(dir_path, file_name));
        }
      };
    })(this));
  };


  /*
  This method load and parse JSON for 'main' part
  while package.json may be invalid or main is missing 
  - some boilerplate code needed
   */

  Resolver.prototype._tryProcessJSON = function(dir_path, file_name, other_file_names, res_cb) {
    var json_path;
    json_path = path.resolve(dir_path, file_name);
    return this._fs_.readFile.get(json_path, (function(_this) {
      return function(err, data) {
        var error, json, main_path;
        if (err) {
          return res_cb(ERROR, err);
        }
        json = null;
        try {
          json = JSON.parse(data);
        } catch (error) {
          err = error;
          return res_cb(ERROR, err);
        }
        if (main_path = json != null ? json.main : void 0) {
          return _this._processFileOrDirectory(main_path, path.dirname(json_path), res_cb);
        } else if (other_file_names.length) {
          _this._debug('package.json missed |main|, return ', path.resolve(dir_path, other_file_names[0]));
          return res_cb(MODULE_FOUND, path.resolve(dir_path, other_file_names[0]));
        } else {
          _this._debug('package.json missed |main| and no index.* founded');
          return res_cb(ERROR, "broken module: no main in |" + json_path + "|, nor index.* files in |" + dir_path + "|");
        }
      };
    })(this));
  };


  /*
  This method process path to find something in path
   */

  Resolver.prototype._processPath = function(path_prefix, path_suffix, res_cb, cb) {
    var patterns;
    this._debug('_processPath', path_prefix, path_suffix);
    patterns = map(this._known_ext_, function(ext) {
      return "" + path_suffix + ext;
    });
    return this._fs_.readdir.get(path_prefix, (function(_this) {
      return function(err, dir) {
        if (err) {
          return res_cb(ERROR, err);
        }
        return cb(_this._multiGrep(dir, [path_suffix].concat(patterns)));
      };
    })(this));
  };


  /*
  This method was multi-grep - filter all values, matched by any pattern
   */

  Resolver.prototype._multiGrep = function(values, patterns) {
    return filter(values, function(val) {
      return some(patterns, function(patt) {
        return val === patt;
      });
    });
  };

  return Resolver;

})();
