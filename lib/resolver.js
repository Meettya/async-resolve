// Generated by CoffeeScript 1.6.1

/*
This class implement node.js require.resolve() behavior, with some enhancements:
  - resolve by given 'basedir'
  - do it async (really async, no one sync function used)

Also it support additional extensions (may be set in constructor).

May be used as successor of https://github.com/substack/node-resolve.
Not drop-in, but mostly worked with some changes
*/


(function() {
  var AsyncCache, Resolver, fs, path, _,
    _this = this,
    __slice = [].slice;

  fs = require('fs');

  path = require('path');

  _ = require('lodash');

  AsyncCache = require('async-cache');

  Resolver = (function() {
    var CORE_MODULES, CORE_MODULES_LIST, ERROR, MODULE_FOUND, MODULE_NOT_FOUND;

    CORE_MODULES_LIST = ['_debugger', '_linklist', '_stream_duplex', '_stream_passthrough', '_stream_readable', '_stream_transform', '_stream_writable', 'assert', 'buffer', 'child_process', 'cluster', 'console', 'constants', 'crypto', 'dgram', 'dns', 'domain', 'events', 'freelist', 'fs', 'http', 'https', 'module', 'net', 'os', 'path', 'punycode', 'querystring', 'readline', 'repl', 'stream', 'string_decoder', 'sys', 'timers', 'tls', 'tty', 'url', 'util', 'vm', 'zlib'];

    CORE_MODULES = _.reduce(CORE_MODULES_LIST, (function(memo, val) {
      memo[val] = true;
      return memo;
    }), {});

    MODULE_FOUND = 'module.found';

    MODULE_NOT_FOUND = 'module.not_found';

    ERROR = 'error';

    /*
    May used with options, default are:
    
    options =
      log : off
      extensions  : ['.js', '.json', '.node']
    
    as base I use settings from https://github.com/substack/node-resolve
    */


    function Resolver(_options_) {
      var _ref, _ref1,
        _this = this;
      this._options_ = _options_ != null ? _options_ : {};
      this._buldResultCallback = function(path_name, basedir, main_cb) {
        return Resolver.prototype._buldResultCallback.apply(_this, arguments);
      };
      this._do_logging_ = (this._options_.log != null) && this._options_.log === true && ((typeof console !== "undefined" && console !== null ? console.log : void 0) != null) ? true : false;
      this._node_modules_dirname_ = (_ref = this._options_.modules) != null ? _ref : 'node_modules';
      this._known_ext_ = (_ref1 = this._options_.extensions) != null ? _ref1 : ['.js', '.json', '.node'];
      this._dir_load_steps_ = ['package.json'].concat(this._buildDirLoadSteps(this._known_ext_));
      this._fs_ = {
        stat: this._buildCachedFunction('fs.stat'),
        readdir: this._buildCachedFunction('fs.readdir'),
        exists: this._buildCachedFunction('fs.exists'),
        readFile: this._buildCachedFunction('fs.readFile')
      };
    }

    /*
    Alias to resolveAbsolutePath()
    */


    Resolver.prototype.resolve = function() {
      var args;
      args = 1 <= arguments.length ? __slice.call(arguments, 0) : [];
      return this.resolveAbsolutePath.apply(this, args);
    };

    /*
    This method create absolute path for file loader
    */


    Resolver.prototype.resolveAbsolutePath = function(path_name, basedir, main_cb) {
      var res_cb;
      res_cb = this._buldResultCallback(path_name, basedir, main_cb);
      switch (path_name.charAt(0)) {
        case '.':
        case path.sep:
          this._debug('This is file or directory', path_name);
          return this._processFileOrDirectory(path_name, basedir, res_cb);
        default:
          this._debug('This is module', path_name);
          return this._processModule(path_name, basedir, res_cb);
      }
    };

    /*
    This method will used to add extensions, keep based untouched
    */


    Resolver.prototype.addExtensions = function() {
      var extensions;
      extensions = 1 <= arguments.length ? __slice.call(arguments, 0) : [];
      this._known_ext_ = this._known_ext_.concat(extensions);
      return this._dir_load_steps_ = this._dir_load_steps_.concat(this._buildDirLoadSteps(extensions));
    };

    /*
    This method get internal state, may be used in tests and debug
    */


    Resolver.prototype.getState = function() {
      return {
        log: this._do_logging_,
        extensions: this._known_ext_,
        dir_load_steps: this._dir_load_steps_,
        modules: this._node_modules_dirname_
      };
    };

    /*
    This method chech is filename is core module
    */


    Resolver.prototype.isCoreModule = function(filename) {
      return CORE_MODULES[filename] != null;
    };

    /*
    This internal method create res_cb - result callback
    its wrapper form main_cb with some checker, bulded as event emmiter substitutor
    to fix bug - events are global and shared to all async execution, 
    and, yes, its case some numbers returns
    */


    Resolver.prototype._buldResultCallback = function(path_name, basedir, main_cb) {
      var _this = this;
      return function(event_name, in_data) {
        var err;
        switch (event_name) {
          case MODULE_FOUND:
            _this._debug('MODULE_FOUND FROM EVENT');
            return main_cb(null, in_data);
          case MODULE_NOT_FOUND:
            _this._debug('MODULE_NOT_FOUND FROM EVENT');
            err = new Error("Cannot find module |" + path_name + "| at basedir |" + basedir + "|");
            err.code = 'MODULE_NOT_FOUND';
            return main_cb(err);
          case ERROR:
            return main_cb(new Error(in_data));
          default:
            _this._debug("WTF!!?? unknow event " + event_name);
            return main_cb(new Error("can`t do |" + event_name + "|"));
        }
      };
    };

    /*
    This method buld cached function
    */


    Resolver.prototype._buildCachedFunction = function(function_name) {
      var load, max, maxAge;
      max = function_name === 'fs.readFile' ? 100 : 1000;
      maxAge = 1000 * 5;
      load = (function() {
        switch (function_name) {
          case 'fs.stat':
            return function(key, cb) {
              return fs.stat(key, cb);
            };
          case 'fs.readdir':
            return function(key, cb) {
              return fs.readdir(key, cb);
            };
          case 'fs.exists':
            return function(key, cb) {
              return fs.exists(key, cb);
            };
          case 'fs.readFile':
            return function(key, cb) {
              return fs.readFile(key, cb);
            };
          default:
            throw Error("WTF!!?? unknow cached function name " + function_name);
        }
      })();
      return new AsyncCache({
        max: max,
        maxAge: maxAge,
        load: load
      });
    };

    /*
    This internal method create directory resolution patterns in correct steps
    */


    Resolver.prototype._buildDirLoadSteps = function(extensions) {
      return _.map(extensions, function(val) {
        return "index" + val;
      });
    };

    /*
    Short-cut debugging
    */


    Resolver.prototype._debug = function() {
      var args;
      args = 1 <= arguments.length ? __slice.call(arguments, 0) : [];
      if (this._do_logging_) {
        console.log.apply(console, args);
      }
      return null;
    };

    /*
    This method process module
    */


    Resolver.prototype._processModule = function(path_name, basedir, res_cb) {
      var detect_series, detector,
        _this = this;
      if (this.isCoreModule(path_name)) {
        return res_cb(MODULE_FOUND, path_name);
      }
      detector = function(val, cb) {
        var test_path;
        test_path = path.resolve(val, path_name);
        return _this._fs_.exists.get(test_path, function(res) {
          return cb(res);
        });
      };
      detect_series = function() {
        var int_res_cb, other_paths, try_path;
        int_res_cb = arguments[0], try_path = arguments[1], other_paths = 3 <= arguments.length ? __slice.call(arguments, 2) : [];
        if (!try_path) {
          return int_res_cb(MODULE_NOT_FOUND);
        }
        return detector(try_path, function(is_exist) {
          if (is_exist) {
            return _this._processFileOrDirectory(path_name, try_path, int_res_cb);
          } else {
            return detect_series.apply(null, [int_res_cb].concat(__slice.call(other_paths)));
          }
        });
      };
      return detect_series.apply(null, [res_cb].concat(__slice.call(this._buildNodeModulesPathes(basedir))));
    };

    /*
    Build all possible node_modules dirs for selected dir
    code was adapted from node\lib\module.js
    */


    Resolver.prototype._buildNodeModulesPathes = function(from) {
      var all_paths, idx, parts, tip;
      parts = from.split(path.sep);
      all_paths = (function() {
        var _i, _len, _results;
        _results = [];
        for (idx = _i = 0, _len = parts.length; _i < _len; idx = ++_i) {
          tip = parts[idx];
          if (tip !== this._node_modules_dirname_) {
            _results.push(path.join.apply(path, [path.sep].concat(__slice.call(parts.slice(0, idx + 1)), [this._node_modules_dirname_])));
          }
        }
        return _results;
      }).call(this);
      return all_paths.reverse();
    };

    /*
    This internal method resolve situation if more than one file was defined in directory
    In this case resolution will be based on extension order
    */


    Resolver.prototype._resolveFileByExtentionOrder = function(files) {
      var ext, res, _i, _len, _ref;
      _ref = this._known_ext_;
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        ext = _ref[_i];
        if ((res = _.find(files, function(val) {
          return ext === path.extname(val);
        }))) {
          return res;
        }
      }
    };

    /*
    This method process file or directory
    */


    Resolver.prototype._processFileOrDirectory = function(path_name, basedir, res_cb) {
      var path_prefix, path_suffix,
        _this = this;
      path_name = path.resolve(basedir, path_name);
      path_prefix = path.dirname(path_name);
      path_suffix = path.basename(path_name);
      return this._processPath(path_prefix, path_suffix, res_cb, function(filtered) {
        var first_filtered;
        _this._debug('_processFileOrDirectory filtered', filtered);
        switch (filtered.length) {
          case 0:
            _this._debug('Not found');
            return res_cb(MODULE_NOT_FOUND);
          case 1:
            _this._debug('find one');
            return _this._processGodsend(path.resolve(path_prefix, filtered[0]), res_cb);
          default:
            _this._debug('find some files, resolve by extension order', filtered);
            first_filtered = _this._resolveFileByExtentionOrder(filtered);
            return _this._processGodsend(path.resolve(path_prefix, first_filtered), res_cb);
        }
      });
    };

    /*
    This method look closer to our godsend and find out what is it really
    */


    Resolver.prototype._processGodsend = function(thing_path, res_cb) {
      var _this = this;
      return this._fs_.stat.get(thing_path, function(err, stat_obj) {
        if (err) {
          return res_cb(ERROR, err);
        }
        if (stat_obj.isFile()) {
          _this._debug('WAY!!! its file!!!');
          return res_cb(MODULE_FOUND, thing_path);
        } else if (stat_obj.isDirectory()) {
          _this._debug('HM, big directory, not bad :)');
          return _this._processDirectory(thing_path, res_cb);
        } else {
          _this._debug('WTF?? Cant process it, sorry');
          return res_cb(MODULE_NOT_FOUND);
        }
      });
    };

    /*
    This method process directory as node.js resolve
    */


    Resolver.prototype._processDirectory = function(dir_path, res_cb) {
      var _this = this;
      return this._fs_.readdir.get(dir_path, function(err, dir) {
        var file_name, filtered;
        if (err) {
          return res_cb(ERROR, err);
        }
        filtered = _this._multiGrep(_this._dir_load_steps_, dir);
        _this._debug('_processDirectory filtered', filtered);
        switch (file_name = filtered[0]) {
          case void 0:
            _this._debug('Nothing finded, not a module');
            return res_cb(MODULE_NOT_FOUND);
          case 'package.json':
            _this._debug('this is |package.json|');
            return _this._tryProcessJSON(dir_path, file_name, filtered.slice(1), res_cb);
          default:
            _this._debug('just return file', path.resolve(dir_path, file_name));
            return res_cb(MODULE_FOUND, path.resolve(dir_path, file_name));
        }
      });
    };

    /*
    This method load and parse JSON for 'main' part
    while package.json may be invalid or main is missing 
    - some boilerplate code needed
    */


    Resolver.prototype._tryProcessJSON = function(dir_path, file_name, other_file_names, res_cb) {
      var json_path,
        _this = this;
      json_path = path.resolve(dir_path, file_name);
      return this._fs_.readFile.get(json_path, function(err, data) {
        var json, main_path;
        if (err) {
          return res_cb(ERROR, err);
        }
        json = null;
        try {
          json = JSON.parse(data);
        } catch (err) {
          return res_cb(ERROR, err);
        }
        if (main_path = json != null ? json.main : void 0) {
          return _this._processFileOrDirectory(main_path, path.dirname(json_path), res_cb);
        } else if (other_file_names.length) {
          _this._debug('package.json missed |main|, return ', path.resolve(dir_path, other_file_names[0]));
          return res_cb(MODULE_FOUND, path.resolve(dir_path, other_file_names[0]));
        } else {
          _this._debug('package.json missed |main| and no index.* founded');
          return res_cb(ERROR, "broken module: no main in |" + json_path + "|, nor index.* files in |" + dir_path + "|");
        }
      });
    };

    /*
    This method process path to find something in path
    */


    Resolver.prototype._processPath = function(path_prefix, path_suffix, res_cb, cb) {
      var patterns,
        _this = this;
      this._debug('_processPath', path_prefix, path_suffix);
      patterns = _.map(this._known_ext_, function(ext) {
        return "" + path_suffix + ext;
      });
      return this._fs_.readdir.get(path_prefix, function(err, dir) {
        if (err) {
          return res_cb(ERROR, err);
        }
        return cb(_this._multiGrep(dir, [path_suffix].concat(patterns)));
      });
    };

    /*
    This method was multi-grep - filter all values, matched by any pattern
    */


    Resolver.prototype._multiGrep = function(values, patterns) {
      return _.filter(values, function(val) {
        return _.any(patterns, function(patt) {
          return val === patt;
        });
      });
    };

    return Resolver;

  })();

  module.exports = Resolver;

}).call(this);
